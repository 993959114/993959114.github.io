<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>赵兴磊Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://schoderzhao.github.io/"/>
  <updated>2020-07-30T08:25:05.462Z</updated>
  <id>https://schoderzhao.github.io/</id>
  
  <author>
    <name>Schoder</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>RibbitMQ实战教程</title>
    <link href="https://schoderzhao.github.io/2020/07/30/RibbitMQ%E5%AE%9E%E6%88%98%E6%95%99%E7%A8%8B/"/>
    <id>https://schoderzhao.github.io/2020/07/30/RibbitMQ%E5%AE%9E%E6%88%98%E6%95%99%E7%A8%8B/</id>
    <published>2020-07-30T07:35:11.278Z</published>
    <updated>2020-07-30T08:25:05.462Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RabbitMQ-实战教程"><a href="#RabbitMQ-实战教程" class="headerlink" title="RabbitMQ 实战教程"></a>RabbitMQ 实战教程</h1><h2 id="1-MQ引言"><a href="#1-MQ引言" class="headerlink" title="1.MQ引言"></a>1.MQ引言</h2><h3 id="1-1-什么是MQ"><a href="#1-1-什么是MQ" class="headerlink" title="1.1 什么是MQ"></a>1.1 什么是MQ</h3><p>MQ(Message Quene)翻译为 <code>消息队列</code>,通过典型的 <code>生产者</code>和<code>消费者</code>模型,生产者不断向消息队列中生产消息，消费者不断的从队列中获取消息。因为消息的生产和消费都是异步的，而且只关心消息的发送和接收，没有业务逻辑的侵入,轻松的实现系统间解耦。别名为 <code>消息中间件</code> 通过利用高效可靠的消息传递机制进行平台无关的数据交流，并基于数据通信来进行分布式系统的集成。</p><h3 id="1-2-MQ有哪些"><a href="#1-2-MQ有哪些" class="headerlink" title="1.2 MQ有哪些"></a>1.2 MQ有哪些</h3><p>当今市面上有很多主流的消息中间件，如老牌的<code>ActiveMQ</code>、<code>RabbitMQ</code>，炙手可热的<code>Kafka</code>，阿里巴巴自主开发<code>RocketMQ</code>等。</p><h3 id="1-3-不同MQ特点"><a href="#1-3-不同MQ特点" class="headerlink" title="1.3 不同MQ特点"></a>1.3 不同MQ特点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 1.ActiveMQ</span><br><span class="line">        ActiveMQ 是Apache出品，最流行的，能力强劲的开源消息总线。它是一个完全支持JMS规范的的消息中间件。丰富的API,多种集群架构模式让ActiveMQ在业界成为老牌的消息中间件,在中小型企业颇受欢迎!</span><br><span class="line"></span><br><span class="line"># 2.Kafka</span><br><span class="line">        Kafka是LinkedIn开源的分布式发布-订阅消息系统，目前归属于Apache顶级项目。Kafka主要特点是基于Pull的模式来处理消息消费，</span><br><span class="line">        追求高吞吐量，一开始的目的就是用于日志收集和传输。0.8版本开始支持复制，不支持事务，对消息的重复、丢失、错误没有严格要求，</span><br><span class="line">        适合产生大量数据的互联网服务的数据收集业务。</span><br><span class="line"></span><br><span class="line"># 3.RocketMQ</span><br><span class="line">        RocketMQ是阿里开源的消息中间件，它是纯Java开发，具有高吞吐量、高可用性、适合大规模分布式系统应用的特点。RocketMQ思路起</span><br><span class="line">        源于Kafka，但并不是Kafka的一个Copy，它对消息的可靠传输及事务性做了优化，目前在阿里集团被广泛应用于交易、充值、流计算、消</span><br><span class="line">        息推送、日志流式处理、binglog分发等场景。</span><br><span class="line"></span><br><span class="line"># 4.RabbitMQ</span><br><span class="line">        RabbitMQ是使用Erlang语言开发的开源消息队列系统，基于AMQP协议来实现。AMQP的主要特征是面向消息、队列、路由（包括点对点和</span><br><span class="line">        发布&#x2F;订阅）、可靠性、安全。AMQP协议更多用在企业系统内对数据一致性、稳定性和可靠性要求很高的场景，对性能和吞吐量的要求还在</span><br><span class="line">        其次。</span><br></pre></td></tr></table></figure><blockquote><p>RabbitMQ比Kafka可靠，Kafka更适合IO高吞吐的处理，一般应用在大数据日志处理或对实时性（少量延迟），可靠性（少量丢数据）要求稍低的场景使用，比如ELK日志收集。</p></blockquote><hr><h2 id="2-RabbitMQ-的引言"><a href="#2-RabbitMQ-的引言" class="headerlink" title="2.RabbitMQ 的引言"></a>2.RabbitMQ 的引言</h2><h3 id="2-1-RabbitMQ"><a href="#2-1-RabbitMQ" class="headerlink" title="2.1 RabbitMQ"></a>2.1 RabbitMQ</h3><blockquote><p>基于<code>AMQP</code>协议，erlang语言开发，是部署最广泛的开源消息中间件,是最受欢迎的开源消息中间件之一。</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/07/30/RibbitMQ%E5%AE%9E%E6%88%98%E6%95%99%E7%A8%8B/image-20190925215603036-9419777.png" alt="image-20190925215603036" title>                </div>                <div class="image-caption">image-20190925215603036</div>            </figure><p><code>官网</code>: <a href="https://www.rabbitmq.com/" target="_blank" rel="noopener">https://www.rabbitmq.com/</a></p><p><code>官方教程</code>: <a href="https://www.rabbitmq.com/\#getstarted" target="_blank" rel="noopener">https://www.rabbitmq.com/\#getstarted</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># AMQP 协议</span><br><span class="line">       AMQP（advanced message queuing protocol）&#96;在2003年时被提出，最早用于解决金融领不同平台之间的消息传递交互问题。顾名思义，AMQP是一种协议，更准确的说是一种binary wire-level protocol（链接协议）。这是其和JMS的本质差别，AMQP不从API层进行限定，而是直接定义网络交换的数据格式。这使得实现了AMQP的provider天然性就是跨平台的。以下是AMQP协议模型:</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/07/30/RibbitMQ%E5%AE%9E%E6%88%98%E6%95%99%E7%A8%8B/image-20200311182438041.png" alt="image-20200311182438041" title>                </div>                <div class="image-caption">image-20200311182438041</div>            </figure><h3 id="2-2-RabbitMQ-的安装"><a href="#2-2-RabbitMQ-的安装" class="headerlink" title="2.2 RabbitMQ 的安装"></a>2.2 RabbitMQ 的安装</h3><h4 id="2-2-1-下载"><a href="#2-2-1-下载" class="headerlink" title="2.2.1 下载"></a>2.2.1 下载</h4><p><code>官网下载地址</code>: <a href="https://www.rabbitmq.com/download.html" target="_blank" rel="noopener">https://www.rabbitmq.com/download.html</a><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/07/30/RibbitMQ%E5%AE%9E%E6%88%98%E6%95%99%E7%A8%8B/image-20190925220115235.png" alt="image-20190925220115235" title>                </div>                <div class="image-caption">image-20190925220115235</div>            </figure></p><blockquote><p><code>最新版本</code>: 3.7.18</p></blockquote><h4 id="2-2-2-下载的安装包"><a href="#2-2-2-下载的安装包" class="headerlink" title="2.2.2 下载的安装包"></a>2.2.2 下载的安装包<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/07/30/RibbitMQ%E5%AE%9E%E6%88%98%E6%95%99%E7%A8%8B/image-20190925220343521.png" alt="image-20190925220343521" title>                </div>                <div class="image-caption">image-20190925220343521</div>            </figure></h4><blockquote><p><code>注意</code>:这里的安装包是centos7安装的包</p></blockquote><h4 id="2-2-3-安装步骤"><a href="#2-2-3-安装步骤" class="headerlink" title="2.2.3 安装步骤"></a>2.2.3 安装步骤</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 1.将rabbitmq安装包上传到linux系统中</span><br><span class="line">    erlang-22.0.7-1.el7.x86_64.rpm</span><br><span class="line">    rabbitmq-server-3.7.18-1.el7.noarch.rpm</span><br><span class="line"></span><br><span class="line"># 2.安装Erlang依赖包</span><br><span class="line">    rpm -ivh erlang-22.0.7-1.el7.x86_64.rpm</span><br><span class="line"></span><br><span class="line"># 3.安装RabbitMQ安装包(需要联网)</span><br><span class="line">    yum install -y rabbitmq-server-3.7.18-1.el7.noarch.rpm</span><br><span class="line">        注意:默认安装完成后配置文件模板在:&#x2F;usr&#x2F;share&#x2F;doc&#x2F;rabbitmq-server-3.7.18&#x2F;rabbitmq.config.example目录中,需要   </span><br><span class="line">                将配置文件复制到&#x2F;etc&#x2F;rabbitmq&#x2F;目录中,并修改名称为rabbitmq.config</span><br><span class="line"># 4.复制配置文件</span><br><span class="line">    cp &#x2F;usr&#x2F;share&#x2F;doc&#x2F;rabbitmq-server-3.7.18&#x2F;rabbitmq.config.example &#x2F;etc&#x2F;rabbitmq&#x2F;rabbitmq.config</span><br><span class="line"></span><br><span class="line"># 5.查看配置文件位置</span><br><span class="line">    ls &#x2F;etc&#x2F;rabbitmq&#x2F;rabbitmq.config</span><br><span class="line"></span><br><span class="line"># 6.修改配置文件(参见下图:)</span><br><span class="line">    vim &#x2F;etc&#x2F;rabbitmq&#x2F;rabbitmq.config</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/07/30/RibbitMQ%E5%AE%9E%E6%88%98%E6%95%99%E7%A8%8B/image-20190925222230260-3836271.png" alt="image-20190925222230260" title>                </div>                <div class="image-caption">image-20190925222230260</div>            </figure><p>将上图中配置文件中红色部分去掉<code>%%</code>,以及最后的<code>,</code>逗号 修改为下图:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/07/30/RibbitMQ%E5%AE%9E%E6%88%98%E6%95%99%E7%A8%8B/image-20190925222329200-3836312.png" alt="image-20190925222329200" title>                </div>                <div class="image-caption">image-20190925222329200</div>            </figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"># 7.执行如下命令,启动rabbitmq中的插件管理</span><br><span class="line">    rabbitmq-plugins enable rabbitmq_management</span><br><span class="line">    </span><br><span class="line">    出现如下说明:</span><br><span class="line">        Enabling plugins on node rabbit@localhost:</span><br><span class="line">    rabbitmq_management</span><br><span class="line">    The following plugins have been configured:</span><br><span class="line">      rabbitmq_management</span><br><span class="line">      rabbitmq_management_agent</span><br><span class="line">      rabbitmq_web_dispatch</span><br><span class="line">    Applying plugin configuration to rabbit@localhost...</span><br><span class="line">    The following plugins have been enabled:</span><br><span class="line">      rabbitmq_management</span><br><span class="line">      rabbitmq_management_agent</span><br><span class="line">      rabbitmq_web_dispatch</span><br><span class="line"></span><br><span class="line">    set 3 plugins.</span><br><span class="line">    Offline change; changes will take effect at broker restart.</span><br><span class="line"></span><br><span class="line"># 8.启动RabbitMQ的服务</span><br><span class="line">    systemctl start rabbitmq-server</span><br><span class="line">    systemctl restart rabbitmq-server</span><br><span class="line">    systemctl stop rabbitmq-server</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"># 9.查看服务状态(见下图:)</span><br><span class="line">    systemctl status rabbitmq-server</span><br><span class="line">  ● rabbitmq-server.service - RabbitMQ broker</span><br><span class="line">     Loaded: loaded (&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;rabbitmq-server.service; disabled; vendor preset: disabled)</span><br><span class="line">     Active: active (running) since 三 2019-09-25 22:26:35 CST; 7s ago</span><br><span class="line">   Main PID: 2904 (beam.smp)</span><br><span class="line">     Status: &quot;Initialized&quot;</span><br><span class="line">     CGroup: &#x2F;system.slice&#x2F;rabbitmq-server.service</span><br><span class="line">             ├─2904 &#x2F;usr&#x2F;lib64&#x2F;erlang&#x2F;erts-10.4.4&#x2F;bin&#x2F;beam.smp -W w -A 64 -MBas ageffcbf -MHas ageffcbf -</span><br><span class="line">             MBlmbcs...</span><br><span class="line">             ├─3220 erl_child_setup 32768</span><br><span class="line">             ├─3243 inet_gethost 4</span><br><span class="line">             └─3244 inet_gethost 4</span><br><span class="line">      .........</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/07/30/RibbitMQ%E5%AE%9E%E6%88%98%E6%95%99%E7%A8%8B/image-20190925222743776-3836511.png" alt="image-20190925222743776" title>                </div>                <div class="image-caption">image-20190925222743776</div>            </figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 10.关闭防火墙服务</span><br><span class="line">    systemctl disable firewalld</span><br><span class="line">    Removed symlink &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;multi-user.target.wants&#x2F;firewalld.service.</span><br><span class="line">    Removed symlink &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;dbus-org.fedoraproject.FirewallD1.service.</span><br><span class="line">    systemctl stop firewalld   </span><br><span class="line"></span><br><span class="line"># 11.访问web管理界面</span><br><span class="line">    http:&#x2F;&#x2F;10.15.0.8:15672&#x2F;</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/07/30/RibbitMQ%E5%AE%9E%E6%88%98%E6%95%99%E7%A8%8B/image-20190926194738708-3836601.png" alt="image-20190926194738708" title>                </div>                <div class="image-caption">image-20190926194738708</div>            </figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 12.登录管理界面</span><br><span class="line">    username:  guest</span><br><span class="line">    password:  guest</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/07/30/RibbitMQ%E5%AE%9E%E6%88%98%E6%95%99%E7%A8%8B/image-20190926194954822-3836665.png" alt="image-20190926194954822" title>                </div>                <div class="image-caption">image-20190926194954822</div>            </figure><hr><ol start="3"><li>RabiitMQ 配置</li></ol><hr><h3 id="3-1RabbitMQ-管理命令行"><a href="#3-1RabbitMQ-管理命令行" class="headerlink" title="3.1RabbitMQ 管理命令行"></a>3.1RabbitMQ 管理命令行</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 1.服务启动相关</span><br><span class="line">    systemctl start|restart|stop|status rabbitmq-server</span><br><span class="line"></span><br><span class="line"># 2.管理命令行  用来在不使用web管理界面情况下命令操作RabbitMQ</span><br><span class="line">    rabbitmqctl  help  可以查看更多命令</span><br><span class="line"></span><br><span class="line"># 3.插件管理命令行</span><br><span class="line">    rabbitmq-plugins enable|list|disable</span><br></pre></td></tr></table></figure><h3 id="3-2-web管理界面介绍"><a href="#3-2-web管理界面介绍" class="headerlink" title="3.2 web管理界面介绍"></a>3.2 web管理界面介绍</h3><h4 id="3-2-1-overview概览"><a href="#3-2-1-overview概览" class="headerlink" title="3.2.1 overview概览"></a>3.2.1 overview概览</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/07/30/RibbitMQ%E5%AE%9E%E6%88%98%E6%95%99%E7%A8%8B/image-20191126162026720.png" alt="image-20191126162026720" title>                </div>                <div class="image-caption">image-20191126162026720</div>            </figure><ul><li><p><code>connections：无论生产者还是消费者，都需要与RabbitMQ建立连接后才可以完成消息的生产和消费，在这里可以查看连接情况</code></p></li><li><p><code>channels：通道，建立连接后，会形成通道，消息的投递获取依赖通道。</code></p></li><li><p><code>Exchanges：交换机，用来实现消息的路由</code></p></li><li><p><code>Queues：队列，即消息队列，消息存放在队列中，等待消费，消费后被移除队列。</code></p></li></ul><h4 id="3-2-2-Admin用户和虚拟主机管理"><a href="#3-2-2-Admin用户和虚拟主机管理" class="headerlink" title="3.2.2 Admin用户和虚拟主机管理"></a>3.2.2 Admin用户和虚拟主机管理</h4><h5 id="1-添加用户"><a href="#1-添加用户" class="headerlink" title="1. 添加用户"></a>1. 添加用户</h5><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/07/30/RibbitMQ%E5%AE%9E%E6%88%98%E6%95%99%E7%A8%8B/image-20191126162617280.png" alt="image-20191126162617280" title>                </div>                <div class="image-caption">image-20191126162617280</div>            </figure><p>上面的Tags选项，其实是指定用户的角色，可选的有以下几个：</p><ul><li><code>超级管理员(administrator)</code></li></ul><p>可登陆管理控制台，可查看所有的信息，并且可以对用户，策略(policy)进行操作。</p><ul><li><code>监控者(monitoring)</code></li></ul><p>可登陆管理控制台，同时可以查看rabbitmq节点的相关信息(进程数，内存使用情况，磁盘使用情况等)</p><ul><li><code>策略制定者(policymaker)</code></li></ul><p>可登陆管理控制台, 同时可以对policy进行管理。但无法查看节点的相关信息(上图红框标识的部分)。</p><ul><li><code>普通管理者(management)</code></li></ul><p>仅可登陆管理控制台，无法看到节点信息，也无法对策略进行管理。</p><ul><li><code>其他</code></li></ul><p>无法登陆管理控制台，通常就是普通的生产者和消费者。</p><h5 id="2-创建虚拟主机"><a href="#2-创建虚拟主机" class="headerlink" title="2. 创建虚拟主机"></a>2. 创建虚拟主机</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 虚拟主机</span><br><span class="line">    为了让各个用户可以互不干扰的工作，RabbitMQ添加了虚拟主机（Virtual Hosts）的概念。其实就是一个独立的访问路径，不同用户使用不同路径，各自有自己的队列、交换机，互相不会影响。</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/07/30/RibbitMQ%E5%AE%9E%E6%88%98%E6%95%99%E7%A8%8B/image-20191126163023153.png" alt="image-20191126163023153" title>                </div>                <div class="image-caption">image-20191126163023153</div>            </figure><h5 id="3-绑定虚拟主机和用户"><a href="#3-绑定虚拟主机和用户" class="headerlink" title="3. 绑定虚拟主机和用户"></a>3. 绑定虚拟主机和用户</h5><p>创建好虚拟主机，我们还要给用户添加访问权限：</p><p>点击添加好的虚拟主机：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/07/30/RibbitMQ%E5%AE%9E%E6%88%98%E6%95%99%E7%A8%8B/image-20191126163506795.png" alt="image-20191126163506795" title>                </div>                <div class="image-caption">image-20191126163506795</div>            </figure><p>进入虚拟机设置界面:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/07/30/RibbitMQ%E5%AE%9E%E6%88%98%E6%95%99%E7%A8%8B/image-20191126163631889.png" alt="image-20191126163631889" title>                </div>                <div class="image-caption">image-20191126163631889</div>            </figure><hr><h2 id="4-RabbitMQ-的第一个程序"><a href="#4-RabbitMQ-的第一个程序" class="headerlink" title="4.RabbitMQ 的第一个程序"></a>4.RabbitMQ 的第一个程序</h2><h3 id="4-0-AMQP协议的回顾"><a href="#4-0-AMQP协议的回顾" class="headerlink" title="4.0 AMQP协议的回顾"></a>4.0 AMQP协议的回顾</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/07/30/RibbitMQ%E5%AE%9E%E6%88%98%E6%95%99%E7%A8%8B/image-20200312140114784.png" alt="image-20200312140114784" title>                </div>                <div class="image-caption">image-20200312140114784</div>            </figure><h3 id="4-1-RabbitMQ支持的消息模型"><a href="#4-1-RabbitMQ支持的消息模型" class="headerlink" title="4.1 RabbitMQ支持的消息模型"></a>4.1 RabbitMQ支持的消息模型</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/07/30/RibbitMQ%E5%AE%9E%E6%88%98%E6%95%99%E7%A8%8B/image-20191126165434784.png" alt="image-20191126165434784" title>                </div>                <div class="image-caption">image-20191126165434784</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/07/30/RibbitMQ%E5%AE%9E%E6%88%98%E6%95%99%E7%A8%8B/image-20191126165459282.png" alt="image-20191126165459282" title>                </div>                <div class="image-caption">image-20191126165459282</div>            </figure><h3 id="4-2-引入依赖"><a href="#4-2-引入依赖" class="headerlink" title="4.2 引入依赖"></a>4.2 引入依赖</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.rabbitmq&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;amqp-client&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.7.2&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="4-3-第一种模型-直连"><a href="#4-3-第一种模型-直连" class="headerlink" title="4.3 第一种模型(直连)"></a>4.3 第一种模型(直连)</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/07/30/RibbitMQ%E5%AE%9E%E6%88%98%E6%95%99%E7%A8%8B/image-20191126165840602.png" alt="image-20191126165840602" title>                </div>                <div class="image-caption">image-20191126165840602</div>            </figure><p>在上图的模型中，有以下概念：</p><ul><li>P：生产者，也就是要发送消息的程序</li><li>C：消费者：消息的接受者，会一直等待消息到来。</li><li>queue：消息队列，图中红色部分。类似一个邮箱，可以缓存消息；生产者向其中投递消息，消费者从其中取出消息。</li></ul><h5 id="1-开发生产者"><a href="#1-开发生产者" class="headerlink" title="1. 开发生产者"></a>1. 开发生产者</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;创建连接工厂</span><br><span class="line">ConnectionFactory connectionFactory &#x3D; new ConnectionFactory();</span><br><span class="line">connectionFactory.setHost(&quot;10.15.0.9&quot;);</span><br><span class="line">connectionFactory.setPort(5672);</span><br><span class="line">connectionFactory.setUsername(&quot;ems&quot;);</span><br><span class="line">connectionFactory.setPassword(&quot;123&quot;);</span><br><span class="line">connectionFactory.setVirtualHost(&quot;&#x2F;ems&quot;);</span><br><span class="line">Connection connection &#x3D; connectionFactory.newConnection();</span><br><span class="line">&#x2F;&#x2F;创建通道</span><br><span class="line">Channel channel &#x3D; connection.createChannel();</span><br><span class="line">&#x2F;&#x2F;参数1: 是否持久化  参数2:是否独占队列 参数3:是否自动删除  参数4:其他属性</span><br><span class="line">channel.queueDeclare(&quot;hello&quot;,true,false,false,null);</span><br><span class="line">channel.basicPublish(&quot;&quot;,&quot;hello&quot;, null,&quot;hello rabbitmq&quot;.getBytes());</span><br><span class="line">channel.close();</span><br><span class="line">connection.close();</span><br></pre></td></tr></table></figure><h5 id="2-开发消费者"><a href="#2-开发消费者" class="headerlink" title="2. 开发消费者"></a>2. 开发消费者</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;创建连接工厂</span><br><span class="line">ConnectionFactory connectionFactory &#x3D; new ConnectionFactory();</span><br><span class="line">connectionFactory.setHost(&quot;10.15.0.9&quot;);</span><br><span class="line">connectionFactory.setPort(5672);</span><br><span class="line">connectionFactory.setUsername(&quot;ems&quot;);</span><br><span class="line">connectionFactory.setPassword(&quot;123&quot;);</span><br><span class="line">connectionFactory.setVirtualHost(&quot;&#x2F;ems&quot;);</span><br><span class="line">Connection connection &#x3D; connectionFactory.newConnection();</span><br><span class="line">Channel channel &#x3D; connection.createChannel();</span><br><span class="line">channel.queueDeclare(&quot;hello&quot;, true, false, false, null);</span><br><span class="line">channel.basicConsume(&quot;hello&quot;,true,new DefaultConsumer(channel)&#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123;</span><br><span class="line">    System.out.println(new String(body));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="3-参数的说明"><a href="#3-参数的说明" class="headerlink" title="3. 参数的说明"></a>3. 参数的说明</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">channel.queueDeclare(&quot;hello&quot;,true,false,false,null);</span><br><span class="line">  &#39;参数1&#39;:用来声明通道对应的队列</span><br><span class="line">&#39;参数2&#39;:用来指定是否持久化队列</span><br><span class="line">&#39;参数3&#39;:用来指定是否独占队列</span><br><span class="line">&#39;参数4&#39;:用来指定是否自动删除队列</span><br><span class="line">&#39;参数5&#39;:对队列的额外配置</span><br></pre></td></tr></table></figure><hr><h3 id="4-4-第二种模型-work-quene"><a href="#4-4-第二种模型-work-quene" class="headerlink" title="4.4 第二种模型(work quene)"></a>4.4 第二种模型(work quene)</h3><p><code>Work queues</code>，也被称为（<code>Task queues</code>），任务模型。当消息处理比较耗时的时候，可能生产消息的速度会远远大于消息的消费速度。长此以往，消息就会堆积越来越多，无法及时处理。此时就可以使用work 模型：<strong>让多个消费者绑定到一个队列，共同消费队列中的消息</strong>。队列中的消息一旦消费，就会消失，因此任务是不会被重复执行的。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/07/30/RibbitMQ%E5%AE%9E%E6%88%98%E6%95%99%E7%A8%8B/image-20200314221002008.png" alt="image-20200314221002008" title>                </div>                <div class="image-caption">image-20200314221002008</div>            </figure><p>角色：</p><ul><li>P：生产者：任务的发布者</li><li>C1：消费者-1，领取任务并且完成任务，假设完成速度较慢</li><li>C2：消费者-2：领取任务并完成任务，假设完成速度快</li></ul><h5 id="1-开发生产者-1"><a href="#1-开发生产者-1" class="headerlink" title="1. 开发生产者"></a>1. 开发生产者</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">channel.queueDeclare(&quot;hello&quot;, true, false, false, null);</span><br><span class="line">for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">  channel.basicPublish(&quot;&quot;, &quot;hello&quot;, null, (i+&quot;&#x3D;&#x3D;&#x3D;&#x3D;&gt;:我是消息&quot;).getBytes());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-开发消费者-1"><a href="#2-开发消费者-1" class="headerlink" title="2.开发消费者-1"></a>2.开发消费者-1</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">channel.queueDeclare(&quot;hello&quot;,true,false,false,null);</span><br><span class="line">channel.basicConsume(&quot;hello&quot;,true,new DefaultConsumer(channel)&#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123;</span><br><span class="line">    System.out.println(&quot;消费者1: &quot;+new String(body));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="3-开发消费者-2"><a href="#3-开发消费者-2" class="headerlink" title="3.开发消费者-2"></a>3.开发消费者-2</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">channel.queueDeclare(&quot;hello&quot;,true,false,false,null);</span><br><span class="line">channel.basicConsume(&quot;hello&quot;,true,new DefaultConsumer(channel)&#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      Thread.sleep(1000);   &#x2F;&#x2F;处理消息比较慢 一秒处理一个消息</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;消费者2: &quot;+new String(body));  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="4-测试结果"><a href="#4-测试结果" class="headerlink" title="4.测试结果"></a>4.测试结果</h5><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/07/30/RibbitMQ%E5%AE%9E%E6%88%98%E6%95%99%E7%A8%8B/image-20200314223242058.png" alt="image-20200314223242058" title>                </div>                <div class="image-caption">image-20200314223242058</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/07/30/RibbitMQ%E5%AE%9E%E6%88%98%E6%95%99%E7%A8%8B/image-20200314223302207.png" alt="image-20200314223302207" title>                </div>                <div class="image-caption">image-20200314223302207</div>            </figure><blockquote><p><code>总结:默认情况下，RabbitMQ将按顺序将每个消息发送给下一个使用者。平均而言，每个消费者都会收到相同数量的消息。这种分发消息的方式称为循环。</code></p></blockquote><h5 id="5-消息自动确认机制"><a href="#5-消息自动确认机制" class="headerlink" title="5.消息自动确认机制"></a>5.消息自动确认机制</h5><blockquote><p>Doing a task can take a few seconds. You may wonder what happens if one of the consumers starts a long task and dies with it only partly done. With our current code, once RabbitMQ delivers a message to the consumer it immediately marks it for deletion. In this case, if you kill a worker we will lose the message it was just processing. We’ll also lose all the messages that were dispatched to this particular worker but were not yet handled.</p><p>But we don’t want to lose any tasks. If a worker dies, we’d like the task to be delivered to another worker.</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">channel.basicQos(1);&#x2F;&#x2F;一次只接受一条未确认的消息</span><br><span class="line">&#x2F;&#x2F;参数2:关闭自动确认消息</span><br><span class="line">channel.basicConsume(&quot;hello&quot;,false,new DefaultConsumer(channel)&#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123;</span><br><span class="line">    System.out.println(&quot;消费者1: &quot;+new String(body));</span><br><span class="line">    channel.basicAck(envelope.getDeliveryTag(),false);&#x2F;&#x2F;手动确认消息</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li><p>设置通道一次只能消费一个消息</p></li><li><p>关闭消息的自动确认,开启手动确认消息</p></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/07/30/RibbitMQ%E5%AE%9E%E6%88%98%E6%95%99%E7%A8%8B/image-20200314230412178.png" alt="image-20200314230412178" title>                </div>                <div class="image-caption">image-20200314230412178</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/07/30/RibbitMQ%E5%AE%9E%E6%88%98%E6%95%99%E7%A8%8B/image-20200314230423280.png" alt="image-20200314230423280" title>                </div>                <div class="image-caption">image-20200314230423280</div>            </figure><hr><h3 id="4-5-第三种模型-fanout"><a href="#4-5-第三种模型-fanout" class="headerlink" title="4.5 第三种模型(fanout)"></a>4.5 第三种模型(fanout)</h3><p><code>fanout 扇出 也称为广播</code></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/07/30/RibbitMQ%E5%AE%9E%E6%88%98%E6%95%99%E7%A8%8B/image-20191126213115873.png" alt="image-20191126213115873" title>                </div>                <div class="image-caption">image-20191126213115873</div>            </figure><p>在广播模式下，消息发送流程是这样的：</p><ul><li>可以有多个消费者</li><li>每个<strong>消费者有自己的queue</strong>（队列）</li><li>每个<strong>队列都要绑定到Exchange</strong>（交换机）</li><li><strong>生产者发送的消息，只能发送到交换机</strong>，交换机来决定要发给哪个队列，生产者无法决定。</li><li>交换机把消息发送给绑定过的所有队列</li><li>队列的消费者都能拿到消息。实现一条消息被多个消费者消费</li></ul><h5 id="1-开发生产者-2"><a href="#1-开发生产者-2" class="headerlink" title="1. 开发生产者"></a>1. 开发生产者</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;声明交换机</span><br><span class="line">channel.exchangeDeclare(&quot;logs&quot;,&quot;fanout&quot;);&#x2F;&#x2F;广播 一条消息多个消费者同时消费</span><br><span class="line">&#x2F;&#x2F;发布消息</span><br><span class="line">channel.basicPublish(&quot;logs&quot;,&quot;&quot;,null,&quot;hello&quot;.getBytes());</span><br></pre></td></tr></table></figure><h5 id="2-开发消费者-1-1"><a href="#2-开发消费者-1-1" class="headerlink" title="2. 开发消费者-1"></a>2. 开发消费者-1</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;绑定交换机</span><br><span class="line">channel.exchangeDeclare(&quot;logs&quot;,&quot;fanout&quot;);</span><br><span class="line">&#x2F;&#x2F;创建临时队列</span><br><span class="line">String queue &#x3D; channel.queueDeclare().getQueue();</span><br><span class="line">&#x2F;&#x2F;将临时队列绑定exchange</span><br><span class="line">channel.queueBind(queue,&quot;logs&quot;,&quot;&quot;);</span><br><span class="line">&#x2F;&#x2F;处理消息</span><br><span class="line">channel.basicConsume(queue,true,new DefaultConsumer(channel)&#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123;</span><br><span class="line">    System.out.println(&quot;消费者1: &quot;+new String(body));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="3-开发消费者-2-1"><a href="#3-开发消费者-2-1" class="headerlink" title="3. 开发消费者-2"></a>3. 开发消费者-2</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;绑定交换机</span><br><span class="line">channel.exchangeDeclare(&quot;logs&quot;,&quot;fanout&quot;);</span><br><span class="line">&#x2F;&#x2F;创建临时队列</span><br><span class="line">String queue &#x3D; channel.queueDeclare().getQueue();</span><br><span class="line">&#x2F;&#x2F;将临时队列绑定exchange</span><br><span class="line">channel.queueBind(queue,&quot;logs&quot;,&quot;&quot;);</span><br><span class="line">&#x2F;&#x2F;处理消息</span><br><span class="line">channel.basicConsume(queue,true,new DefaultConsumer(channel)&#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123;</span><br><span class="line">    System.out.println(&quot;消费者2: &quot;+new String(body));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="4-开发消费者-3"><a href="#4-开发消费者-3" class="headerlink" title="4.开发消费者-3"></a>4.开发消费者-3</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;绑定交换机</span><br><span class="line">channel.exchangeDeclare(&quot;logs&quot;,&quot;fanout&quot;);</span><br><span class="line">&#x2F;&#x2F;创建临时队列</span><br><span class="line">String queue &#x3D; channel.queueDeclare().getQueue();</span><br><span class="line">&#x2F;&#x2F;将临时队列绑定exchange</span><br><span class="line">channel.queueBind(queue,&quot;logs&quot;,&quot;&quot;);</span><br><span class="line">&#x2F;&#x2F;处理消息</span><br><span class="line">channel.basicConsume(queue,true,new DefaultConsumer(channel)&#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123;</span><br><span class="line">    System.out.println(&quot;消费者3: &quot;+new String(body));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="5-测试结果"><a href="#5-测试结果" class="headerlink" title="5. 测试结果"></a>5. 测试结果</h5><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/07/30/RibbitMQ%E5%AE%9E%E6%88%98%E6%95%99%E7%A8%8B/image-20200315180653207.png" alt="image-20200315180653207" title>                </div>                <div class="image-caption">image-20200315180653207</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/07/30/RibbitMQ%E5%AE%9E%E6%88%98%E6%95%99%E7%A8%8B/image-20200315180708489.png" alt="image-20200315180708489" title>                </div>                <div class="image-caption">image-20200315180708489</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/07/30/RibbitMQ%E5%AE%9E%E6%88%98%E6%95%99%E7%A8%8B/image-20200315180728035.png" alt="image-20200315180728035" title>                </div>                <div class="image-caption">image-20200315180728035</div>            </figure><hr><h3 id="4-6-第四种模型-Routing"><a href="#4-6-第四种模型-Routing" class="headerlink" title="4.6 第四种模型(Routing)"></a>4.6 第四种模型(Routing)</h3><h4 id="4-6-1-Routing-之订阅模型-Direct-直连"><a href="#4-6-1-Routing-之订阅模型-Direct-直连" class="headerlink" title="4.6.1 Routing 之订阅模型-Direct(直连)"></a>4.6.1 Routing 之订阅模型-Direct(直连)</h4><p><code>在Fanout模式中，一条消息，会被所有订阅的队列都消费。但是，在某些场景下，我们希望不同的消息被不同的队列消费。这时就要用到Direct类型的Exchange。</code></p><p>在Direct模型下：</p><ul><li>队列与交换机的绑定，不能是任意绑定了，而是要指定一个<code>RoutingKey</code>（路由key）</li><li>消息的发送方在 向 Exchange发送消息时，也必须指定消息的 <code>RoutingKey</code>。</li><li>Exchange不再把消息交给每一个绑定的队列，而是根据消息的<code>Routing Key</code>进行判断，只有队列的<code>Routingkey</code>与消息的 <code>Routing key</code>完全一致，才会接收到消息</li></ul><p>流程:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/07/30/RibbitMQ%E5%AE%9E%E6%88%98%E6%95%99%E7%A8%8B/image-20191126220145375.png" alt="image-20191126220145375" title>                </div>                <div class="image-caption">image-20191126220145375</div>            </figure><p>图解：</p><ul><li>P：生产者，向Exchange发送消息，发送消息时，会指定一个routing key。</li><li>X：Exchange（交换机），接收生产者的消息，然后把消息递交给 与routing key完全匹配的队列</li><li>C1：消费者，其所在队列指定了需要routing key 为 error 的消息</li><li>C2：消费者，其所在队列指定了需要routing key 为 info、error、warning 的消息</li></ul><h5 id="1-开发生产者-3"><a href="#1-开发生产者-3" class="headerlink" title="1. 开发生产者"></a>1. 开发生产者</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;声明交换机  参数1:交换机名称 参数2:交换机类型 基于指令的Routing key转发</span><br><span class="line">channel.exchangeDeclare(&quot;logs_direct&quot;,&quot;direct&quot;);</span><br><span class="line">String key &#x3D; &quot;&quot;;</span><br><span class="line">&#x2F;&#x2F;发布消息</span><br><span class="line">channel.basicPublish(&quot;logs_direct&quot;,key,null,(&quot;指定的route key&quot;+key+&quot;的消息&quot;).getBytes());</span><br></pre></td></tr></table></figure><h5 id="2-开发消费者-1-2"><a href="#2-开发消费者-1-2" class="headerlink" title="2.开发消费者-1"></a>2.开发消费者-1</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> &#x2F;&#x2F;声明交换机</span><br><span class="line">channel.exchangeDeclare(&quot;logs_direct&quot;,&quot;direct&quot;);</span><br><span class="line">&#x2F;&#x2F;创建临时队列</span><br><span class="line">String queue &#x3D; channel.queueDeclare().getQueue();</span><br><span class="line">&#x2F;&#x2F;绑定队列和交换机</span><br><span class="line">channel.queueBind(queue,&quot;logs_direct&quot;,&quot;error&quot;);</span><br><span class="line">channel.queueBind(queue,&quot;logs_direct&quot;,&quot;info&quot;);</span><br><span class="line">channel.queueBind(queue,&quot;logs_direct&quot;,&quot;warn&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;消费消息</span><br><span class="line">channel.basicConsume(queue,true,new DefaultConsumer(channel)&#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123;</span><br><span class="line">    System.out.println(&quot;消费者1: &quot;+new String(body));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="3-开发消费者-2-2"><a href="#3-开发消费者-2-2" class="headerlink" title="3.开发消费者-2"></a>3.开发消费者-2</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;声明交换机</span><br><span class="line">channel.exchangeDeclare(&quot;logs_direct&quot;,&quot;direct&quot;);</span><br><span class="line">&#x2F;&#x2F;创建临时队列</span><br><span class="line">String queue &#x3D; channel.queueDeclare().getQueue();</span><br><span class="line">&#x2F;&#x2F;绑定队列和交换机</span><br><span class="line">channel.queueBind(queue,&quot;logs_direct&quot;,&quot;error&quot;);</span><br><span class="line">&#x2F;&#x2F;消费消息</span><br><span class="line">channel.basicConsume(queue,true,new DefaultConsumer(channel)&#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123;</span><br><span class="line">    System.out.println(&quot;消费者2: &quot;+new String(body));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="4-测试生产者发送Route-key为error的消息时"><a href="#4-测试生产者发送Route-key为error的消息时" class="headerlink" title="4.测试生产者发送Route key为error的消息时"></a>4.测试生产者发送Route key为error的消息时</h5><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/07/30/RibbitMQ%E5%AE%9E%E6%88%98%E6%95%99%E7%A8%8B/image-20200316102613933.png" alt="image-20200316102613933" title>                </div>                <div class="image-caption">image-20200316102613933</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/07/30/RibbitMQ%E5%AE%9E%E6%88%98%E6%95%99%E7%A8%8B/image-20200316102627912.png" alt="image-20200316102627912" title>                </div>                <div class="image-caption">image-20200316102627912</div>            </figure><h5 id="5-测试生产者发送Route-key为info的消息时"><a href="#5-测试生产者发送Route-key为info的消息时" class="headerlink" title="5.测试生产者发送Route key为info的消息时"></a>5.测试生产者发送Route key为info的消息时</h5><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/07/30/RibbitMQ%E5%AE%9E%E6%88%98%E6%95%99%E7%A8%8B/image-20200316102925740.png" alt="image-20200316102925740" title>                </div>                <div class="image-caption">image-20200316102925740</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/07/30/RibbitMQ%E5%AE%9E%E6%88%98%E6%95%99%E7%A8%8B/image-20200316102947326.png" alt="image-20200316102947326" title>                </div>                <div class="image-caption">image-20200316102947326</div>            </figure><hr><h4 id="4-6-2-Routing-之订阅模型-Topic"><a href="#4-6-2-Routing-之订阅模型-Topic" class="headerlink" title="4.6.2 Routing 之订阅模型-Topic"></a>4.6.2 Routing 之订阅模型-Topic</h4><p><code>Topic</code>类型的<code>Exchange</code>与<code>Direct</code>相比，都是可以根据<code>RoutingKey</code>把消息路由到不同的队列。只不过<code>Topic</code>类型<code>Exchange</code>可以让队列在绑定<code>Routing key</code> 的时候使用通配符！这种模型<code>Routingkey</code> 一般都是由一个或多个单词组成，多个单词之间以”.”分割，例如： <code>item.insert</code></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/07/30/RibbitMQ%E5%AE%9E%E6%88%98%E6%95%99%E7%A8%8B/image-20191127121900255.png" alt="image-20191127121900255" title>                </div>                <div class="image-caption">image-20191127121900255</div>            </figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 统配符</span><br><span class="line">        * (star) can substitute for exactly one word.    匹配不多不少恰好1个词</span><br><span class="line">        # (hash) can substitute for zero or more words.  匹配一个或多个词</span><br><span class="line"># 如:</span><br><span class="line">        audit.#    匹配audit.irs.corporate或者 audit.irs 等</span><br><span class="line">    audit.*   只能匹配 audit.irs</span><br></pre></td></tr></table></figure><h5 id="1-开发生产者-4"><a href="#1-开发生产者-4" class="headerlink" title="1.开发生产者"></a>1.开发生产者</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;生命交换机和交换机类型 topic 使用动态路由(通配符方式)</span><br><span class="line">channel.exchangeDeclare(&quot;topics&quot;,&quot;topic&quot;);</span><br><span class="line">String routekey &#x3D; &quot;user.save&quot;;&#x2F;&#x2F;动态路由key</span><br><span class="line">&#x2F;&#x2F;发布消息</span><br><span class="line">channel.basicPublish(&quot;topics&quot;,routekey,null,(&quot;这是路由中的动态订阅模型,route key: [&quot;+routekey+&quot;]&quot;).getBytes());</span><br></pre></td></tr></table></figure><h5 id="2-开发消费者-1-3"><a href="#2-开发消费者-1-3" class="headerlink" title="2.开发消费者-1"></a>2.开发消费者-1</h5><p><code>Routing Key中使用*通配符方式</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> &#x2F;&#x2F;声明交换机</span><br><span class="line">channel.exchangeDeclare(&quot;topics&quot;,&quot;topic&quot;);</span><br><span class="line">&#x2F;&#x2F;创建临时队列</span><br><span class="line">String queue &#x3D; channel.queueDeclare().getQueue();</span><br><span class="line">&#x2F;&#x2F;绑定队列与交换机并设置获取交换机中动态路由</span><br><span class="line">channel.queueBind(queue,&quot;topics&quot;,&quot;user.*&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;消费消息</span><br><span class="line">channel.basicConsume(queue,true,new DefaultConsumer(channel)&#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123;</span><br><span class="line">    System.out.println(&quot;消费者1: &quot;+new String(body));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="3-开发消费者-2-3"><a href="#3-开发消费者-2-3" class="headerlink" title="3.开发消费者-2"></a>3.开发消费者-2</h5><p><code>Routing Key中使用#通配符方式</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;声明交换机</span><br><span class="line">channel.exchangeDeclare(&quot;topics&quot;,&quot;topic&quot;);</span><br><span class="line">&#x2F;&#x2F;创建临时队列</span><br><span class="line">String queue &#x3D; channel.queueDeclare().getQueue();</span><br><span class="line">&#x2F;&#x2F;绑定队列与交换机并设置获取交换机中动态路由</span><br><span class="line">channel.queueBind(queue,&quot;topics&quot;,&quot;user.#&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;消费消息</span><br><span class="line">channel.basicConsume(queue,true,new DefaultConsumer(channel)&#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123;</span><br><span class="line">    System.out.println(&quot;消费者2: &quot;+new String(body));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="4-测试结果-1"><a href="#4-测试结果-1" class="headerlink" title="4.测试结果"></a>4.测试结果</h5><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/07/30/RibbitMQ%E5%AE%9E%E6%88%98%E6%95%99%E7%A8%8B/image-20200316113935785.png" alt="image-20200316113935785" title>                </div>                <div class="image-caption">image-20200316113935785</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/07/30/RibbitMQ%E5%AE%9E%E6%88%98%E6%95%99%E7%A8%8B/image-20200316114000459.png" alt="image-20200316114000459" title>                </div>                <div class="image-caption">image-20200316114000459</div>            </figure><ol start="5"><li>SpringBoot中使用RabbitMQ</li></ol><hr><h3 id="5-0-搭建初始环境"><a href="#5-0-搭建初始环境" class="headerlink" title="5.0 搭建初始环境"></a>5.0 搭建初始环境</h3><h5 id="1-引入依赖"><a href="#1-引入依赖" class="headerlink" title="1. 引入依赖"></a>1. 引入依赖</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-boot-starter-amqp&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><h5 id="2-配置配置文件"><a href="#2-配置配置文件" class="headerlink" title="2. 配置配置文件"></a>2. 配置配置文件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: springboot_rabbitmq</span><br><span class="line">  rabbitmq:</span><br><span class="line">    host: 10.15.0.9</span><br><span class="line">    port: 5672</span><br><span class="line">    username: ems</span><br><span class="line">    password: 123</span><br><span class="line">    virtual-host: &#x2F;ems</span><br></pre></td></tr></table></figure><p><code>RabbitTemplate</code> 用来简化操作 使用时候直接在项目中注入即可使用</p><h3 id="5-1-第一种hello-world模型使用"><a href="#5-1-第一种hello-world模型使用" class="headerlink" title="5.1 第一种hello world模型使用"></a>5.1 第一种hello world模型使用</h3><ol><li>##### 开发生产者</li></ol><p>```java @Autowired private RabbitTemplate rabbitTemplate;</p><p>@Test public void testHello(){ rabbitTemplate.convertAndSend(“hello”,”hello world”); } ```</p><ol><li>##### 开发消费者</li></ol><p>```java @Component @RabbitListener(queuesToDeclare = @Queue(“hello”)) public class HelloCustomer {</p><pre><code>@RabbitHandlerpublic void receive1(String message){    System.out.println(&quot;message = &quot; + message);}</code></pre><p>} ```</p><h3 id="5-2-第二种work模型使用"><a href="#5-2-第二种work模型使用" class="headerlink" title="5.2 第二种work模型使用"></a>5.2 第二种work模型使用</h3><ol><li>##### 开发生产者</li></ol><p>```java @Autowired private RabbitTemplate rabbitTemplate;</p><p>@Test public void testWork(){ for (int i = 0; i &lt; 10; i++) { rabbitTemplate.convertAndSend(“work”,”hello work!”); } } ```</p><ol><li>##### 开发消费者</li></ol><p>```java @Component public class WorkCustomer { @RabbitListener(queuesToDeclare = @Queue(“work”)) public void receive1(String message){ System.out.println(“work message1 = “ + message); }</p><pre><code>@RabbitListener(queuesToDeclare = @Queue(&quot;work&quot;))public void receive2(String message){    System.out.println(&quot;work message2 = &quot; + message);}</code></pre><p>} ```</p><blockquote><p><code>说明:默认在Spring AMQP实现中Work这种方式就是公平调度,如果需要实现能者多劳需要额外配置</code></p></blockquote><h3 id="5-3-Fanout-广播模型"><a href="#5-3-Fanout-广播模型" class="headerlink" title="5.3 Fanout 广播模型"></a>5.3 Fanout 广播模型</h3><ol><li>##### 开发生产者</li></ol><p>```java @Autowired private RabbitTemplate rabbitTemplate;</p><p>@Test public void testFanout() throws InterruptedException { rabbitTemplate.convertAndSend(“logs”,””,”这是日志广播”); } ```</p><ol><li>##### 开发消费者</li></ol><p>```java @Component public class FanoutCustomer {</p><pre><code>@RabbitListener(bindings = @QueueBinding(        value = @Queue,        exchange = @Exchange(name=&quot;logs&quot;,type = &quot;fanout&quot;)))public void receive1(String message){    System.out.println(&quot;message1 = &quot; + message);}@RabbitListener(bindings = @QueueBinding(        value = @Queue, //创建临时队列        exchange = @Exchange(name=&quot;logs&quot;,type = &quot;fanout&quot;)  //绑定交换机类型))public void receive2(String message){    System.out.println(&quot;message2 = &quot; + message);}</code></pre><p>} ```</p><h3 id="5-4-Route-路由模型"><a href="#5-4-Route-路由模型" class="headerlink" title="5.4 Route 路由模型"></a>5.4 Route 路由模型</h3><ol><li>##### 开发生产者</li></ol><p>```java @Autowired private RabbitTemplate rabbitTemplate;</p><p>@Test public void testDirect(){ rabbitTemplate.convertAndSend(“directs”,”error”,”error 的日志信息”); } ```</p><ol><li>##### 开发消费者</li></ol><p>```java @Component public class DirectCustomer {</p><pre><code>@RabbitListener(bindings ={        @QueueBinding(                value = @Queue(),                key={&quot;info&quot;,&quot;error&quot;},                exchange = @Exchange(type = &quot;direct&quot;,name=&quot;directs&quot;)        )})public void receive1(String message){    System.out.println(&quot;message1 = &quot; + message);}@RabbitListener(bindings ={        @QueueBinding(                value = @Queue(),                key={&quot;error&quot;},                exchange = @Exchange(type = &quot;direct&quot;,name=&quot;directs&quot;)        )})public void receive2(String message){    System.out.println(&quot;message2 = &quot; + message);}</code></pre><p>}</p><p>```</p><h3 id="5-5-Topic-订阅模型-动态路由模型"><a href="#5-5-Topic-订阅模型-动态路由模型" class="headerlink" title="5.5 Topic 订阅模型(动态路由模型)"></a>5.5 Topic 订阅模型(动态路由模型)</h3><ol><li>##### 开发生产者</li></ol><p>```java @Autowired private RabbitTemplate rabbitTemplate;</p><p>//topic @Test public void testTopic(){ rabbitTemplate.convertAndSend(“topics”,”user.save.findAll”,”user.save.findAll 的消息”); } ```</p><ol><li>##### 开发消费者</li></ol><p>```java @Component public class TopCustomer { @RabbitListener(bindings = { @QueueBinding( value = @Queue, key = {“user.*“}, exchange = @Exchange(type = “topic”,name = “topics”) ) }) public void receive1(String message){ System.out.println(“message1 = “ + message); }</p><pre><code>@RabbitListener(bindings = {        @QueueBinding(                value = @Queue,                key = {&quot;user.#&quot;},                exchange = @Exchange(type = &quot;topic&quot;,name = &quot;topics&quot;)        )})public void receive2(String message){    System.out.println(&quot;message2 = &quot; + message);}</code></pre><p>} ```</p><hr><ol start="6"><li>MQ的应用场景</li></ol><hr><h3 id="6-1-异步处理"><a href="#6-1-异步处理" class="headerlink" title="6.1 异步处理"></a>6.1 异步处理</h3><p><code>场景说明：用户注册后，需要发注册邮件和注册短信,传统的做法有两种 1.串行的方式 2.并行的方式</code></p><ul><li><code>串行方式:</code> 将注册信息写入数据库后,发送注册邮件,再发送注册短信,以上三个任务全部完成后才返回给客户端。 这有一个问题是,邮件,短信并不是必须的,它只是一个通知,而这种做法让客户端等待没有必要等待的东西.</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/07/30/RibbitMQ%E5%AE%9E%E6%88%98%E6%95%99%E7%A8%8B/SouthEast-4860248.png" alt="这里写图片描述" title>                </div>                <div class="image-caption">这里写图片描述</div>            </figure><ul><li><code>并行方式:</code>将注册信息写入数据库后,发送邮件的同时,发送短信,以上三个任务完成后,返回给客户端,并行的方式能提高处理的时间。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/07/30/RibbitMQ%E5%AE%9E%E6%88%98%E6%95%99%E7%A8%8B/SouthEast-20191127211112660.png" alt="这里写图片描述" title>                </div>                <div class="image-caption">这里写图片描述</div>            </figure><ul><li><code>消息队列:</code>假设三个业务节点分别使用50ms,串行方式使用时间150ms,并行使用时间100ms。虽然并行已经提高的处理时间,但是,前面说过,邮件和短信对我正常的使用网站没有任何影响，客户端没有必要等着其发送完成才显示注册成功,应该是写入数据库后就返回. <code>消息队列</code>: 引入消息队列后，把发送邮件,短信不是必须的业务逻辑异步处理</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/07/30/RibbitMQ%E5%AE%9E%E6%88%98%E6%95%99%E7%A8%8B/592892-20190520220249900-1679743651.jpg" alt="img" title>                </div>                <div class="image-caption">img</div>            </figure><p>由此可以看出,引入消息队列后，用户的响应时间就等于写入数据库的时间+写入消息队列的时间(可以忽略不计),引入消息队列后处理后,响应时间是串行的3倍,是并行的2倍。</p><h3 id="6-2-应用解耦"><a href="#6-2-应用解耦" class="headerlink" title="6.2 应用解耦"></a>6.2 应用解耦</h3><p><code>场景：双11是购物狂节,用户下单后,订单系统需要通知库存系统,传统的做法就是订单系统调用库存系统的接口.</code></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/07/30/RibbitMQ%E5%AE%9E%E6%88%98%E6%95%99%E7%A8%8B/SouthEast-20191127211247287.png" alt="这里写图片描述" title>                </div>                <div class="image-caption">这里写图片描述</div>            </figure><p>这种做法有一个缺点:</p><p>当库存系统出现故障时,订单就会失败。 订单系统和库存系统高耦合. 引入消息队列</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/07/30/RibbitMQ%E5%AE%9E%E6%88%98%E6%95%99%E7%A8%8B/SouthEast-20191127211304085.png" alt="这里写图片描述" title>                </div>                <div class="image-caption">这里写图片描述</div>            </figure><ul><li><p><code>订单系统:</code>用户下单后,订单系统完成持久化处理,将消息写入消息队列,返回用户订单下单成功。</p></li><li><p><code>库存系统:</code>订阅下单的消息,获取下单消息,进行库操作。 就算库存系统出现故障,消息队列也能保证消息的可靠投递,不会导致消息丢失.</p></li></ul><h3 id="6-3-流量削峰"><a href="#6-3-流量削峰" class="headerlink" title="6.3 流量削峰"></a>6.3 流量削峰</h3><p><code>场景:</code> 秒杀活动，一般会因为流量过大，导致应用挂掉,为了解决这个问题，一般在应用前端加入消息队列。</p><p><code>作用:</code></p><pre><code>1.可以控制活动人数，超过此一定阀值的订单直接丢弃(我为什么秒杀一次都没有成功过呢^^) 2.可以缓解短时间的高流量压垮应用(应用程序按自己的最大处理能力获取订单) </code></pre><p><img src="/2020/07/30/RibbitMQ%E5%AE%9E%E6%88%98%E6%95%99%E7%A8%8B/SouthEast-20191127211341601.png" alt="这里写图片描述"></p><p>1.用户的请求,服务器收到之后,首先写入消息队列,加入消息队列长度超过最大值,则直接抛弃用户请求或跳转到错误页面.</p><p>2.秒杀业务根据消息队列中的请求信息，再做后续处理.</p><hr><ol start="7"><li>RabbitMQ的集群</li></ol><hr><h3 id="7-1-集群架构"><a href="#7-1-集群架构" class="headerlink" title="7.1 集群架构"></a>7.1 集群架构</h3><h4 id="7-1-1-普通集群-副本集群"><a href="#7-1-1-普通集群-副本集群" class="headerlink" title="7.1.1 普通集群(副本集群)"></a>7.1.1 普通集群(副本集群)</h4><blockquote><p>All data/state required for the operation of a RabbitMQ broker is replicated across all nodes. An exception to this are message queues, which by default reside on one node, though they are visible and reachable from all nodes. To replicate queues across nodes in a cluster –摘自官网</p></blockquote><p><code>默认情况下:RabbitMQ代理操作所需的所有数据/状态都将跨所有节点复制。这方面的一个例外是消息队列，默认情况下，消息队列位于一个节点上，尽管它们可以从所有节点看到和访问</code></p><ol><li>##### 架构图</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/07/30/RibbitMQ%E5%AE%9E%E6%88%98%E6%95%99%E7%A8%8B/image-20200320094147471.png" alt="image-20200320094147471" title>                </div>                <div class="image-caption">image-20200320094147471</div>            </figure><pre><code>核心解决问题:  `当集群中某一时刻master节点宕机,可以对Quene中信息,进行备份`</code></pre><ol><li>##### 集群搭建</li></ol><p>```markdown # 0.集群规划 node1: 10.15.0.3 mq1 master 主节点 node2: 10.15.0.4 mq2 repl1 副本节点 node3: 10.15.0.5 mq3 repl2 副本节点</p><p># 1.克隆三台机器主机名和ip映射 vim /etc/hosts加入: 10.15.0.3 mq1 10.15.0.4 mq2 10.15.0.5 mq3 node1: vim /etc/hostname 加入: mq1 node2: vim /etc/hostname 加入: mq2 node3: vim /etc/hostname 加入: mq3</p><p># 2.三个机器安装rabbitmq,并同步cookie文件,在node1上执行: scp /var/lib/rabbitmq/.erlang.cookie root@mq2:/var/lib/rabbitmq/ scp /var/lib/rabbitmq/.erlang.cookie root@mq3:/var/lib/rabbitmq/</p><p># 3.查看cookie是否一致: node1: cat /var/lib/rabbitmq/.erlang.cookie node2: cat /var/lib/rabbitmq/.erlang.cookie node3: cat /var/lib/rabbitmq/.erlang.cookie</p><p># 4.后台启动rabbitmq所有节点执行如下命令,启动成功访问管理界面: rabbitmq-server -detached</p><p># 5.在node2和node3执行加入集群命令: 1.关闭 rabbitmqctl stop_app 2.加入集群 rabbitmqctl join_cluster rabbit@mq1 3.启动服务 rabbitmqctl start_app</p><p># 6.查看集群状态,任意节点执行: rabbitmqctl cluster_status</p><p># 7.如果出现如下显示,集群搭建成功: Cluster status of node rabbit@mq3 … [{nodes,[{disc,[rabbit@mq1,rabbit@mq2,rabbit@mq3]}]}, {running_nodes,[rabbit@mq1,rabbit@mq2,rabbit@mq3]}, {cluster_name,&lt;<a href="mailto:" rabbit@mq1"">“rabbit@mq1”</a>&gt;}, {partitions,[]}, {alarms,[{rabbit@mq1,[]},{rabbit@mq2,[]},{rabbit@mq3,[]}]}]</p><p># 8.登录管理界面,展示如下状态: ```</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/07/30/RibbitMQ%E5%AE%9E%E6%88%98%E6%95%99%E7%A8%8B/image-20200320095613586.png" alt="image-20200320095613586" title>                </div>                <div class="image-caption">image-20200320095613586</div>            </figure><p><code>markdown    # 9.测试集群在node1上,创建队列</code></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/07/30/RibbitMQ%E5%AE%9E%E6%88%98%E6%95%99%E7%A8%8B/image-20200320095743935.png" alt="image-20200320095743935" title>                </div>                <div class="image-caption">image-20200320095743935</div>            </figure><p><code>markdown    # 10.查看node2和node3节点:</code></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/07/30/RibbitMQ%E5%AE%9E%E6%88%98%E6%95%99%E7%A8%8B/image-20200320095827688.png" alt="image-20200320095827688" title>                </div>                <div class="image-caption">image-20200320095827688</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/07/30/RibbitMQ%E5%AE%9E%E6%88%98%E6%95%99%E7%A8%8B/image-20200320095843370.png" alt="image-20200320095843370" title>                </div>                <div class="image-caption">image-20200320095843370</div>            </figure><p><code>markdown    # 11.关闭node1节点,执行如下命令,查看node2和node3:     rabbitmqctl stop_app</code></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/07/30/RibbitMQ%E5%AE%9E%E6%88%98%E6%95%99%E7%A8%8B/image-20200320100000347.png" alt="image-20200320100000347" title>                </div>                <div class="image-caption">image-20200320100000347</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/07/30/RibbitMQ%E5%AE%9E%E6%88%98%E6%95%99%E7%A8%8B/image-20200320100010968.png" alt="image-20200320100010968" title>                </div>                <div class="image-caption">image-20200320100010968</div>            </figure><hr><h4 id="7-1-2-镜像集群"><a href="#7-1-2-镜像集群" class="headerlink" title="7.1.2 镜像集群"></a>7.1.2 镜像集群</h4><blockquote><p>This guide covers mirroring (queue contents replication) of classic queues –摘自官网</p><p>By default, contents of a queue within a RabbitMQ cluster are located on a single node (the node on which the queue was declared). This is in contrast to exchanges and bindings, which can always be considered to be on all nodes. Queues can optionally be made <em>mirrored</em> across multiple nodes. –摘自官网</p></blockquote><p><code>镜像队列机制就是将队列在三个节点之间设置主从关系，消息会在三个节点之间进行自动同步，且如果其中一个节点不可用，并不会导致消息丢失或服务不可用的情况，提升MQ集群的整体高可用性。</code></p><ol><li>##### 集群架构图</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/07/30/RibbitMQ%E5%AE%9E%E6%88%98%E6%95%99%E7%A8%8B/image-20200320113423235.png" alt="image-20200320113423235" title>                </div>                <div class="image-caption">image-20200320113423235</div>            </figure><ol><li>##### 配置集群架构</li></ol><p>```markdown # 0.策略说明 rabbitmqctl set_policy [-p <vhost>] [–priority <priority>] [–apply-to <apply-to>] <name> <pattern> <definition> -p Vhost： 可选参数，针对指定vhost下的queue进行设置 Name: policy的名称 Pattern: queue的匹配模式(正则表达式) Definition：镜像定义，包括三个部分ha-mode, ha-params, ha-sync-mode ha-mode:指明镜像队列的模式，有效值为 all/exactly/nodes all：表示在集群中所有的节点上进行镜像 exactly：表示在指定个数的节点上进行镜像，节点的个数由ha-params指定 nodes：表示在指定的节点上进行镜像，节点名称通过ha-params指定 ha-params：ha-mode模式需要用到的参数 ha-sync-mode：进行队列中消息的同步方式，有效值为automatic和manual priority：可选参数，policy的优先级</definition></pattern></name></apply-to></priority></vhost></p><p># 1.查看当前策略 rabbitmqctl list_policies</p><p># 2.添加策略 rabbitmqctl set_policy ha-all ‘^hello’ ‘{“ha-mode”:”all”,”ha-sync-mode”:”automatic”}’ 说明:策略正则表达式为 “^” 表示所有匹配所有队列名称 ^hello:匹配hello开头队列</p><p># 3.删除策略 rabbitmqctl clear_policy ha-all</p><p># 4.测试集群 ```</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;RabbitMQ-实战教程&quot;&gt;&lt;a href=&quot;#RabbitMQ-实战教程&quot; class=&quot;headerlink&quot; title=&quot;RabbitMQ 实战教程&quot;&gt;&lt;/a&gt;RabbitMQ 实战教程&lt;/h1&gt;&lt;h2 id=&quot;1-MQ引言&quot;&gt;&lt;a href=&quot;#1-M
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>FastDfs详解</title>
    <link href="https://schoderzhao.github.io/2020/07/14/FastDfs%E8%AF%A6%E8%A7%A3/"/>
    <id>https://schoderzhao.github.io/2020/07/14/FastDfs%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-07-14T03:06:07.064Z</published>
    <updated>2020-07-14T10:07:56.298Z</updated>
    
    <content type="html"><![CDATA[<h1 id="FastDfs介绍"><a href="#FastDfs介绍" class="headerlink" title="FastDfs介绍"></a>FastDfs介绍</h1><h2 id="分布式文件系统"><a href="#分布式文件系统" class="headerlink" title="分布式文件系统"></a>分布式文件系统</h2><p>静态资源服务器</p><p>图片服务器(在分布式环境中，部署多个同样的系统可以共享。多个不一样的系统也可以共</p><p>享资源)。</p><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>什么是FastDFS</p><p>FastDFS是用c语言编写的一款开源的分布式文件系统。FastDFS为互</p><p>联网量身定制，充分考虑了冗余备份、负载均衡、线性扩容等机制，并</p><p>注重高可用、高性能等指标，使用FastDFS很容易搭建一套高性能的文</p><p>件服务器集群提供文件上传、下载等服务。</p><p>FastDFS是一个开源的轻量级分布式文件系统，它对文件进行管理，功能包括：文件存</p><p>储、文件同步、文件访问（文件上传、文件下载）等，解决了大容量存储和负载均衡的问</p><p>题。特别适合以文件为载体的在线服务，如相册网站、视频网站等等。</p><p><a href="https://baike.baidu.com/item/fastdfs" target="_blank" rel="noopener">https://baike.baidu.com/item/fastdfs</a></p><p>和之前对比，把上传的位置做了变化。这次把图片上传到远程的图片服务器。分布式共享。</p><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/07/14/FastDfs%E8%AF%A6%E8%A7%A3/1.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>文件上传时序图：(按照时间的请求顺序)</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/07/14/FastDfs%E8%AF%A6%E8%A7%A3/2.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>在存储服务器上存储了具体的内容，返回给客户端的只是存储的地<br>址， 以后就拿这个远程的地址就可以访问到文件了。</p><p>下载文件时序图</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/07/14/FastDfs%E8%AF%A6%E8%A7%A3/3.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>下载案例：<br><a href="http://mirrors.tuna.tsinghua.edu.cn/apache/tomcat/tomcat-9/v9.0.13/bin/apachetomcat-" target="_blank" rel="noopener">http://mirrors.tuna.tsinghua.edu.cn/apache/tomcat/tomcat-9/v9.0.13/bin/apachetomcat-</a><br>9.0.13.zip<br>有地址，部署在web服务器，就支持直接下载。<br>开源地址：<br><a href="https://github.com/happyfish100" target="_blank" rel="noopener">https://github.com/happyfish100</a></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/07/14/FastDfs%E8%AF%A6%E8%A7%A3/4.png" alt title>                </div>                <div class="image-caption"></div>            </figure>FastDfs安装<h1 id="FastDfs安装"><a href="#FastDfs安装" class="headerlink" title="FastDfs安装"></a>FastDfs安装</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>一台虚拟机来模拟，一个Tracker、一个Storage服务。配和nginx访问<br>图片。</p><p>(因为需要对外访问，最后可以通过域名访问到图片。)<br><a href="https://www.baidu.com/img/bd_logo1.png" target="_blank" rel="noopener">https://www.baidu.com/img/bd_logo1.png</a></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/07/14/FastDfs%E8%AF%A6%E8%A7%A3/5.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>下载:<a href="https://github.com/happyfish100" target="_blank" rel="noopener">https://github.com/happyfish100</a></p><h2 id="初始环境"><a href="#初始环境" class="headerlink" title="初始环境"></a>初始环境</h2><p>所需软件: 链接 <a href="https://pan.baidu.com/s/1DcUH0TngCiR2LAsLxHWZIg" target="_blank" rel="noopener">https://pan.baidu.com/s/1DcUH0TngCiR2LAsLxHWZIg</a> 提取码 mfdp</p><p>软件上传：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/07/14/FastDfs%E8%AF%A6%E8%A7%A3/6.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>在线安装libevent工具包：<br>确认是否安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa | grep libevent</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/07/14/FastDfs%E8%AF%A6%E8%A7%A3/7.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>（已安装不需要装,没有安装需要装）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/07/14/FastDfs%E8%AF%A6%E8%A7%A3/8.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install libevent</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/07/14/FastDfs%E8%AF%A6%E8%A7%A3/9.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="安装libfastcommon工具包"><a href="#安装libfastcommon工具包" class="headerlink" title="安装libfastcommon工具包"></a>安装libfastcommon工具包</h3><p>解压缩: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip libfastcommon-master.zip</span><br></pre></td></tr></table></figure><p>若unzip命令没找到:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install -y unzip zip</span><br><span class="line">.&#x2F;make.sh</span><br><span class="line">.&#x2F;make.sh install</span><br></pre></td></tr></table></figure><p>若32位目录中没有libfastcommon.so文件，就<br>把/usr/lib64/libfastcommon.so文件向/usr/lib/下复制一份<br>（新版红色框部分标示32位、64位目录都已安装。）</p><p>解压：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/07/14/FastDfs%E8%AF%A6%E8%A7%A3/10.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>编译与安装：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/07/14/FastDfs%E8%AF%A6%E8%A7%A3/11.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>观察：可以兼容32,64位系统</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/07/14/FastDfs%E8%AF%A6%E8%A7%A3/12.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="Tracker服务安装"><a href="#Tracker服务安装" class="headerlink" title="Tracker服务安装"></a>Tracker服务安装</h3><p>安装Tracker服务,这只是一个监听服务。<br>1)解压缩: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip fastdfs-master.zip</span><br></pre></td></tr></table></figure><p>2)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;make.sh</span><br></pre></td></tr></table></figure><p>3)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;make.sh install</span><br></pre></td></tr></table></figure><p>:安装后在/usr/bin/目录下有以fdfs开头的文件<br>都是编译出来的。配置文件都放到/etc/fdfs文件夹<br>4)把/opt/qf/fastdfs/fastdfs-master/conf目录下的所有的配置文件<br>都复制到/etc/fdfs下(从源码的配置文件/opt/qf/fastdfs-soft/fastdfsmaster/<br>conf/*中复制)。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp &#x2F;opt&#x2F;qf&#x2F;fastdfs&#x2F;fastdfs-master&#x2F;conf&#x2F;* &#x2F;etc&#x2F;fdfs&#x2F;</span><br></pre></td></tr></table></figure><p>5)配置tracker服务。修改/ etc/fdfs /tracker.conf文件。<br>base_path=/home/shuju/fastdfs[手动创建目录]<br>http.server_port=85<br>6)启动tracker。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;bin&#x2F;fdfs_trackerd &#x2F;etc&#x2F;fdfs&#x2F;tracker.conf</span><br></pre></td></tr></table></figure><p>重启使用命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;bin&#x2F;fdfs_trackerd &#x2F;etc&#x2F;fdfs&#x2F;tracker.conf</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">restart</span><br></pre></td></tr></table></figure><h3 id="Storage服务安装"><a href="#Storage服务安装" class="headerlink" title="Storage服务安装"></a>Storage服务安装</h3><p>安装storage服务,这个就是真正的存储服务。<br>如果是在不同的服务器安装，第三步的1~4需要重新执行。这里我们在<br>同样一台服务器，不再需要对源码进行重复的编译和安装,仅仅只需要<br>配置storage服务。修改/ etc/fdfs /storage.conf文件</p><p>Storage存储和日志存放路径:<br>base_path=/home/shuju/fastdfs<br>图片保持路径: store_path0=/home/shuju/fastdfs<br>指定Tracker服务器: tracker_server=101.21.26.229<br>:22122(阿里云使用外网IP,正常公司内部的正式服务器也只有内网IP)<br>http.server_port=85 # 此处需要和后面 nginx 监听端口保<br>持一致<br>启动storage服务<br>启动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;bin&#x2F;fdfs_storaged &#x2F;etc&#x2F;fdfs&#x2F;storage.conf</span><br></pre></td></tr></table></figure><p>日志/home/shuju/fdfs/logs/storaged.log 外网若链接不成功<br>改内网IP<br>重启:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;bin&#x2F;fdfs_storaged &#x2F;etc&#x2F;fdfs&#x2F;storage.conf</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">restart</span><br></pre></td></tr></table></figure><h3 id="链接成功-测试服务"><a href="#链接成功-测试服务" class="headerlink" title="链接成功,测试服务"></a>链接成功,测试服务</h3><p>测试需要使用客户端的配置文件，所以需要修改配置文<br>件/etc/fdfs/client.conf</p><p>客户端日志保持base_path=/home/shuju/fastdfs<br>指定Tracker服务器: tracker_server= 101.21.26.229<br>:22122(外网IP)<br>http.tracker_server_port=85 (配置nginx)</p><p><strong>测试指令一：</strong><br>指令的位置:/usr/bin<br>上传图片：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;fdfs_upload_file &#x2F;etc&#x2F;fdfs&#x2F;client.conf &#x2F;etc&#x2F;fdfs&#x2F;anti-steal.jpg</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/07/14/FastDfs%E8%AF%A6%E8%A7%A3/tp.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>存储地址：<br>group1/M00/00/00/rBGMA1q4VqqATqNmAABdrZgsqUU938.jpg</p><p>真实地址：<br>服务器存储地址:/home/shuju/fastdfs/data/00/00</p><p><strong>测试指令二：</strong><br>上传图片：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;fdfs_test &#x2F;etc&#x2F;fdfs&#x2F;client.conf upload &#x2F;etc&#x2F;fdfs&#x2F;anti-steal.jpg</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/07/14/FastDfs%E8%AF%A6%E8%A7%A3/xxx.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>显示有完整url ：<br><a href="http://192.168.132.134:85/group1/M00/00/00/wKiEhlvUNWWAAjA5AAFl0YAhvnQ243.jpg" target="_blank" rel="noopener">http://192.168.132.134:85/group1/M00/00/00/wKiEhlvUNWWAAjA5AAFl0YAhvnQ243.jpg</a><br>这个路径是后来可以通过域名的方式直接访问</p><p>注意：防火墙放行：22122 23000 两个端口</p><p>通过java程序实现上传下载具体代码:</p><p><a href="https://github.com/SchoderZhao/fastdfsDemo" target="_blank" rel="noopener">https://github.com/SchoderZhao/fastdfsDemo</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;FastDfs介绍&quot;&gt;&lt;a href=&quot;#FastDfs介绍&quot; class=&quot;headerlink&quot; title=&quot;FastDfs介绍&quot;&gt;&lt;/a&gt;FastDfs介绍&lt;/h1&gt;&lt;h2 id=&quot;分布式文件系统&quot;&gt;&lt;a href=&quot;#分布式文件系统&quot; class=&quot;he
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Spring事务传播行为种类</title>
    <link href="https://schoderzhao.github.io/2020/06/17/Spring%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA%E7%A7%8D%E7%B1%BB/"/>
    <id>https://schoderzhao.github.io/2020/06/17/Spring%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA%E7%A7%8D%E7%B1%BB/</id>
    <published>2020-06-17T02:33:11.398Z</published>
    <updated>2020-06-17T02:58:12.683Z</updated>
    
    <content type="html"><![CDATA[<hr><p>title: Spring事务传播行为种类<br>date: 2020-06-17 10:33:11</p><h2 id="tags-Sprig"><a href="#tags-Sprig" class="headerlink" title="tags:Sprig"></a>tags:Sprig</h2><h3 id="Spring在TransactionDefinition接口中规定了7种类型的事务传播行为，它们规定了事务方法和事务方法发生嵌套调用时事务如何进行传播："><a href="#Spring在TransactionDefinition接口中规定了7种类型的事务传播行为，它们规定了事务方法和事务方法发生嵌套调用时事务如何进行传播：" class="headerlink" title="Spring在TransactionDefinition接口中规定了7种类型的事务传播行为，它们规定了事务方法和事务方法发生嵌套调用时事务如何进行传播："></a>Spring在TransactionDefinition接口中规定了7种类型的事务传播行为，它们规定了事务方法和事务方法发生嵌套调用时事务如何进行传播：</h3><table><thead><tr><th>事务传播行为类型</th><th>说明</th></tr></thead><tbody><tr><td>PROPAGATION_REQUIRED</td><td>如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。这是最常见的选择。</td></tr><tr><td>PROPAGATION_SUPPORTS</td><td>支持当前事务，如果当前没有事务，就以非事务方式执行。</td></tr><tr><td>PROPAGATION_MANDATORY</td><td>使用当前的事务，如果当前没有事务，就抛出异常。</td></tr><tr><td>PROPAGATION_REQUIRES_NEW</td><td>新建事务，如果当前存在事务，把当前事务挂起。</td></tr><tr><td>PROPAGATION_NOT_SUPPORTED</td><td>以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</td></tr><tr><td>PROPAGATION_NEVER</td><td>以非事务方式执行，如果当前存在事务，则抛出异常。</td></tr><tr><td>PROPAGATION_NESTED</td><td>如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。</td></tr></tbody></table><p>当使用PROPAGATION_NESTED时，底层的数据源必须基于JDBC 3.0，并且实现者需要支持保存点事务机制。</p><p>@Transactional(propagation=Propagation.REQUIRED) 事务传播行为种类（注解方式）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;title: Spring事务传播行为种类&lt;br&gt;date: 2020-06-17 10:33:11&lt;/p&gt;
&lt;h2 id=&quot;tags-Sprig&quot;&gt;&lt;a href=&quot;#tags-Sprig&quot; class=&quot;headerlink&quot; title=&quot;tags:Spri
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>git使用</title>
    <link href="https://schoderzhao.github.io/2020/06/16/git%E4%BD%BF%E7%94%A8/"/>
    <id>https://schoderzhao.github.io/2020/06/16/git%E4%BD%BF%E7%94%A8/</id>
    <published>2020-06-16T08:55:30.409Z</published>
    <updated>2020-06-16T09:39:55.491Z</updated>
    
    <content type="html"><![CDATA[<h1 id="git-基本操作"><a href="#git-基本操作" class="headerlink" title="git 基本操作"></a>git 基本操作</h1><p>1、创建一个项目</p><p>2、打开项目   在项目目录下右键单击–打开 git bash</p><p>3、初始化项目仓库   创建项目仓库</p><p>命令 ： git init</p><p>git config –global user.name &lt;名字&gt; ———&gt;:配置用户名</p><p>git config –global user.email &lt;邮箱&gt;———&gt;：配置邮箱</p><p>git config –list ———&gt;：查看配置信息</p><p>git config –global user.name  ———&gt;：查看用户名</p><p>git config –global user.email ——–&gt; :查看邮箱</p><p>git status  查看文件是否被git管理</p><p>4、添加文件   </p><p>  git add 文件名   一次只能添加一个文件</p><p>  全部添加 ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add ./--all/-A/*</span><br></pre></td></tr></table></figure><p>5、提交</p><p>   git commit -m”日志描述”</p><p>6、项目文件内容如果有变动  先 git add . 再 git commit -m”日志”</p><p>7、git log 查看项目日志</p><p>8、回退操作  </p><p>  git reset –hard 前六位编码</p><p>9、恢复手动删除的文件  git checkout 提交生成码 文件名</p><h1 id="分支操作-："><a href="#分支操作-：" class="headerlink" title="分支操作 ："></a>分支操作 ：</h1><p>1、查看分支  git branch</p><p>2、创建分支  git branch 分支名</p><p>3、切换分支  git checkout 分支名</p><p>4、删除分支  git branch -d 分支名</p><p>5、合并分支  git merge  分支名</p><p>多人协作开发(接下来用张三、李四、CTO三人来演示工作中的流程)：</p><p>1、张三克隆文件：git clone &lt;地址&gt; 文件夹名称</p><p>2、李四克隆文件：git clone &lt;地址&gt; 文件夹名称</p><p>3、张三在开发过程中需要解决BUG</p><p>4、李四在开发过程中需要开发新的功能</p><h1 id="张三解决BUG并提交文件："><a href="#张三解决BUG并提交文件：" class="headerlink" title="张三解决BUG并提交文件："></a>张三解决BUG并提交文件：</h1><p>1、创建子分支：git branch zhangsan</p><p>2、切换子分支：git checkout zhangsan</p><p>3、提交到暂存区：git add index.html</p><p>4、提交到版本库：git commit -m “张三提交”</p><p>5、关联远程分支：git push –set-upstream origin zhangsan (这一步只需第一次的时候这样做即可，第二次修改文件的时候就可以直接执行第6步)</p><p>6、提交文件：git push</p><h1 id="CTO合并文件："><a href="#CTO合并文件：" class="headerlink" title="CTO合并文件："></a>CTO合并文件：</h1><p>1、更新本地的分支：git fetch –all</p><p>2、切换子分支：git checkout zhangsan</p><p>3、切换主分支：git checkout master</p><p>4、合并文件：git merge zhangsan   (：wq 按下回车)</p><p>5、提交到远端：git push</p><p>6、删除子分支：git checkout -d zhangsan  (不需要操作 )</p><h1 id="李四开发新的功能，但是李四的文件还是以前有bug的文件，因此我们需要最新的代码："><a href="#李四开发新的功能，但是李四的文件还是以前有bug的文件，因此我们需要最新的代码：" class="headerlink" title="李四开发新的功能，但是李四的文件还是以前有bug的文件，因此我们需要最新的代码："></a>李四开发新的功能，但是李四的文件还是以前有bug的文件，因此我们需要最新的代码：</h1><p>1、创建并切换子分支：git checkout -b lisi</p><p>fle</p><p>2、将开发好的新功能提交到版本库：git add index.html    git commit -m “李四提交”</p><p>3、切换主分支：git checkout master</p><p>4、将远端最新的代码拉取下来：git pull</p><p>5、切换子分支：git checkout lisi</p><p>6、合并主分支文件：git merge master</p><p>7、退出文件：esc 输入wq</p><p>8、提交到远端：git push –set-upstream origin lisi</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;git-基本操作&quot;&gt;&lt;a href=&quot;#git-基本操作&quot; class=&quot;headerlink&quot; title=&quot;git 基本操作&quot;&gt;&lt;/a&gt;git 基本操作&lt;/h1&gt;&lt;p&gt;1、创建一个项目&lt;/p&gt;
&lt;p&gt;2、打开项目   在项目目录下右键单击–打开 git bas
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Maven中scope标签作用</title>
    <link href="https://schoderzhao.github.io/2020/06/16/Maven%E4%B8%ADscope%E6%A0%87%E7%AD%BE%E4%BD%9C%E7%94%A8/"/>
    <id>https://schoderzhao.github.io/2020/06/16/Maven%E4%B8%ADscope%E6%A0%87%E7%AD%BE%E4%BD%9C%E7%94%A8/</id>
    <published>2020-06-16T08:41:12.055Z</published>
    <updated>2020-07-14T03:15:16.099Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="Maven中scope标签作用"><a href="#Maven中scope标签作用" class="headerlink" title="Maven中scope标签作用"></a>Maven中scope标签作用</h1><p>scope 是用来限制 dependency 的作用范围的，影响 maven 项目在各个生命周期时导入的 package 的状态，主要管理依赖的部署。</p><h2 id="scope-的作用范围："><a href="#scope-的作用范围：" class="headerlink" title="scope 的作用范围："></a>scope 的作用范围：</h2><p>（1）compile：默认值，适用于所有阶段（表明该 jar 包在编译、运行以及测试中路径均可见），并且会随着项目一起发布。</p><p>（2）test：只在测试时使用，用于编译和运行测试代码，不会随项目发布。</p><p>（3）runtime：无需参与项目的编译，不过后期的测试和运行周期需要其参与，与 compile 相比，跳过了编译。如 JDBC 驱动，适用运行和测试阶段。</p><p>（4）provided：编译和测试时有效，但是该依赖在运行时由服务器提供，并且打包时也不会被包含进去。如 servlet-api。</p><p>（5）system：类似 provided，需要显式提供包含依赖的jar，不会从 maven 仓库下载，而是从本地文件系统获取，需要添加 systemPath 的属性来定义路径。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h1 id=&quot;Maven中scope标签作用&quot;&gt;&lt;a href=&quot;#Maven中scope标签作用&quot; class=&quot;headerlink&quot; title=&quot;Maven中scope标签作用&quot;&gt;&lt;/a&gt;Maven中scope标签作用&lt;/h1&gt;&lt;p&gt;scope 是用来限制 d
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>java</title>
    <link href="https://schoderzhao.github.io/2020/06/15/java/"/>
    <id>https://schoderzhao.github.io/2020/06/15/java/</id>
    <published>2020-06-15T08:34:57.000Z</published>
    <updated>2020-06-15T08:34:57.440Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
</feed>
